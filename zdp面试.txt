一：aop 的实现原理
1：aop 是面向切面编程，通过代理类的方式对业务进行增强，主要分为两个步骤， 代理类的生成和代理类的调用。如果目标对象没有实现接口，则通过CGLIB 动态代理（通过对字节码的修改生成子类），如果目标对象有实现接口，则通过jdk动态代理（利用反射机制实现接口的方式生成动态代理类）
2：对代理类的调用，每个bean 都有很多个拦截器方法，分为由spring内核控制的外层拦截器 和用户定义的内层拦截器（aop）,当调用代理对象时，会触发外层拦截器，外层拦截器根据 aop 的代理配置，进行匹配判断生成内层的拦截器链，通过执行完整个拦截器链的过程，完成了对代理对象的调用。
二：aop 的实现技术？
Spring AOP和AspectJ AOP有什么区别？

Spring AOP是属于运行时增强，而AspectJ是编译时增强。Spring AOP基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。

Spring AOP已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。

如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多。

主要的实现技术是ASPECTJ 和spring aop
1：aspectj 的底层技术是静态代理，通过命令来编译，生成一个新的代理类，该代理类增强了业务，这是在编译器增强，相对于运行时增强，编译时增强性能更好
2：spring aop 采用的是动态代理类，是在运行时进行业务的增强，不会生成新的类，根据有没有实现接口可以使用 jdk 动态代理类和 cglib 动态代理的技术

jdk 代理的类需要实现接口，通过实现InvocationHandler 接口来创建一个代理类，（在invoke 方法中做业务处理）该类实现了目标类的所有接口。
cglib 动态代理需要依赖asm包，把被代理对象类的class文件加载进来，修改字节码的方式来生成子类。
spring aop 基于注解配置的情况下，需要依赖ASPECTJ 包的标准注解；要在 Spring 中声明 AspectJ 切面, 只需要在 IOC 容器中将切面声明为 Bean 实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面相匹配的 Bean 创建代理。
三：spring bean 的生命周期？
大致分为：
实例化（bean 的定义），属性赋值，初始化，销毁（容器关闭）
https://www.cnblogs.com/shoshana-kong/p/10692887.html

四：NIO 和BIO 的区别
BIO是一个连接一个线程。同步并阻塞

NIO是一个请求一个线程。同步非阻塞

AIO是一个有效请求一个线程。异步非阻塞

BIO:每个客户端请求会分配一个线程来单独处理，由于每创建一个线程，就会为该线程分配一定的内存空间，操作系统本身会对线程数量有一定的限制，当客户端的请求越来越多的话，服务端可能因为不堪重负拒绝客户端的请求，甚至服务器会因此而瘫痪。
NIO:当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器（selector）上，所以，所有的连接只需要要一个线程就可以，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求对应一个线程模式。
当一个请求过来之后，开启线程进行处理，可能会等待后端的应用的资源（例如JDBC连接），其实这个线程被阻塞了，当并发上来之后，还是会出现BIO 一样的问题。
AIO： 异步非阻塞IO;客户端的请求过来之后，直接调用api的read 或write操作，read 和write操作是异步的，完成后会主动调用回调函数，相当于 客户端的I/O请求都是由OS（操作系统）先完成了再通知服务器应用去启动线程进行处理。充分调用OS（操作系统）参与并发操做。所以是一个有效的请求对应一个线程。
BIO方式适用于连接数目比较小且固定的架构
NIO方式适用于连接数目多且连接比较短
AIO方式使用于连接数目多且连接比较长
五：dubbo和springcloud 的区别
dubbo 是一款RPC 框架，springcloud 是微服务架构下的一站式解决方案。dubbo 的底层是使用netty 的NIO 架构，基于tcp协议传输，配置hession序列化完成rpc通信。
rpc(远程方法调用，远程过程调用)

springcloud 采用的是基于http的rest方式，需要三次握手，传输报文较大，性能相比较低。但是rest 相比RPC 更加灵活。dubbo 服务提供方和调用方之间依赖太强

springcloud 的注册中心是zookeeper,在cap 定理下保证的是CP ，一致性和分区容错

springcloud 的注册中心是 euraka,保证的是AP ，可用性和分区容错性。

SpringCloud社区活跃度远高于Dubbo


